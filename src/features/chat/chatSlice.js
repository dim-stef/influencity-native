import {createAsyncThunk, createSlice} from '@reduxjs/toolkit';
import Config from 'react-native-config';
import {GiftedChat} from 'react-native-gifted-chat';
import axios from 'axios';

export const getMyChatRooms = createAsyncThunk(
  'chat/getMyChatRooms',
  async () => {
    const url = Config.API_URL + '/v1/my_chat_rooms/';
    try {
      let response = await axios.get(url);
      return response.data;
    } catch (e) {
      console.error(e);
    }
  },
);

export const getChatRoomMessages = createAsyncThunk(
  'chat/getChatRoomMessages',
  async (id, thunkApi) => {
    const url = `${Config.API_URL}/v1/my_chat_rooms/${id}/messages/`;
    try {
      let response = await axios.get(url);
      return [id, response.data];
    } catch (e) {
      console.error(e);
    }
  },
);

export const chatSlice = createSlice({
  name: 'chat',
  initialState: {
    myChatRooms: [],
  },
  reducers: {
    addMessages(state, action) {
      let {room, newMessages, pending = false} = action.payload;
      // newMessages is actually an array with a single item
      // I just decided to follow the documentation as is and use an array
      let foundChatRoom = state.myChatRooms.findIndex((r) => r.id == room.id);

      // if the message contains the pending attribute then addMessages was called from the
      // client side instead of a ws event. This is used for instant user feedback when he sends a message
      // instead of waiting the ws to respond back with the message
      // This means that we have to handle when we mark a message as pending or received

      if (newMessages[0].sent === undefined) {
        // we land here from a ws event
        // find the pending message
        // because we don't have the id generated by the servers we find the message
        // that has the same text and is pending
        let pendingMessageIndex = state.myChatRooms[
          foundChatRoom
        ].messages.findIndex((m) => m.text == newMessages[0].text && !m.sent);
        console.log(pendingMessageIndex);
        if (pendingMessageIndex != -1) {
          // assigning the sent value for gifted chat
          newMessages[0].sent = true;
          state.myChatRooms[foundChatRoom].messages[pendingMessageIndex] =
            newMessages[0];
        }
      } else {
        // we land here from client side
        state.myChatRooms[foundChatRoom].messages = GiftedChat.append(
          state.myChatRooms[foundChatRoom].messages,
          newMessages,
        );
      }
      console.log(JSON.stringify(state.myChatRooms[foundChatRoom], null, 2));
    },
  },
  extraReducers: {
    [getMyChatRooms.fulfilled]: (state, action) => {
      state.myChatRooms = action.payload;
    },
    [getMyChatRooms.pending]: () => {},
    [getMyChatRooms.rejected]: () => {},
    [getChatRoomMessages.fulfilled]: (state, action) => {
      const [id, data] = action.payload;
      let foundChatRoom = state.myChatRooms.findIndex((room) => room.id == id);
      // if there is no "messages" attribute populate it with the initial data
      if (!state.myChatRooms[foundChatRoom].messages) {
        state.myChatRooms[foundChatRoom].messages = data.results;
        // else just append them to the already existing message array
      } else {
        /*state.myChatRooms[foundChatRoom].messages = [
          ...data.results,
          ...state.myChatRooms[foundChatRoom].messages,
        ];*/
        state.myChatRooms[foundChatRoom].messages = GiftedChat.append(
          state.myChatRooms[foundChatRoom].messages,
          data.results,
        );
      }
    },
    [getChatRoomMessages.pending]: (state, action) => {},
    [getChatRoomMessages.rejected]: (state, action) => {},
  },
});

export const {addMessages} = chatSlice.actions;
